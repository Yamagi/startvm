#!/bin/sh

# Copyright (c) 2014 - 2019 Yamagi Burmeister
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# -------------------------------------------------------------------- #

# Simple script to run a Bhvye virtual machine. You need to edit this
# script to match your setup! Before running this script make sure
# that the following kernel modules are loaded:
#  - if_bridge.ko
#  - if_tap.ko
#  - nmdm.ko
#  - vmm.ko
#
# All instances of this script must share the same configuration dir,
# otherwise strange things will happen. To boot guests with the grub
# boot option the grub2-bhyve port must be installed.
#
# If a vncviewer is installed, the script can launch it with the 'vnc'
# command on supported VMs. net/tigervnc is recommended. Otherwise the
# VNC port is printed.

# -------------------------------------------------------------------- #

# Source system wide configuration
SCRIPTPATH=`readlink -f "$0"`
SCRIPTPATH=`dirname "$SCRIPTPATH"`
. $SCRIPTPATH/system.cfg

# -------------------------------------------------------------------- #

# Print usage.
usage() {
	echo "Usage: ./startvm cmd [vmname]"
	echo ""
	echo "Commands:"
	echo " - cons:   Open a serial console to the guest"
	echo " - halt:   Send an ACPI shutdown request to the guest"
	echo " - help:   This message"
	echo " - kill:   Kill the VM"
	echo " - list:   List all known VMs"
	echo " - run:    Run the VM"
	echo " - status: Show status"
	echo " - vnc:    Run vncviewer or print the VNC port"
	exit 1
}

# -------------------------------------------------------------------- #

# Debug output.
dbg() {
	if [ $DEBUG -ne 0 ] ; then
		echo $@ >&2
	fi
}

# Builds a command list containing all
# given CDROMs connected to one disk
# controller.
buildcdromlist() {
	CMD=""

	dbg "Building CDROM list"

	# Compatibility cruft for old configs
	if [ ! -z $CDROM ] ; then
		if [ $CDROM == "0" ] ; then
			return
		fi

		CMD="$CMD -s 4,ahci-cd,$CDROM "
	else
		CNT=0

		for CDROM in $(listvariables CDROM[0-9]\*) ; do
			# Evil hack to evalute the contents of $CDROM
			# as variable. For example: $$CDROM -> $CDROM0
			# -> /path/to/iso
			eval CDROM=\"\$$CDROM\"

			if [ $CDROM == "0" ] ; then
				continue
			fi

			CMD="$CMD -s 4:$CNT,ahci-cd,$CDROM "
			CNT=$(($CNT + 1))
		done
	fi

	echo "$CMD"
}

# Builds a command list containing all given HDDs
# connected to one type of disk controller.
#
# Behavior of this function has grown somewhat
# overcomplicated. Depending on the device type
# it generates:
#
#  - ahci-hd:
#      One AHCI controller per HDD.
#
#  - virtio-blk:
#      One VirtIO block storage controller per HDD.
#
#  - ahci:
#      One AHCI controller for all HHDs.
#
#  - nvme:
#      Ome NVMe controller per HDD.
buildhddlist() {
	CMD=""

	dbg "Building HDD list"

	# Old configs are forced to ahci-hd.
	if [ -z $HDTYPE ] ; then
		HDTYPE=ahci-hd
	fi

	# Compatibility cruft for old configs.
	if [ ! -z $HD ] ; then
		if [ $HD == "0" ] ; then
			return
		fi

		CMD="$CMD -s 3,$HDTYPE,$HD"

		# Even more cruft
		if [ -z $SECTORSIZE ] ; then
			if [ $GOP_SECTORSIZE != 0 ] ; then
				CMD="$CMD,sectorsize=$GOP_SECTORSIZE "
			else
				CMD="$CMD "
			fi
		else
			if [ $SECTORSIZE != 0 ] ; then
				CMD="$CMD,sectorsize=$SECTORSIZE "
			else
				CMD="$CMD "
			fi
		fi
	else
		if [ "$HDTYPE" == "ahci-hd" -o "$HDTYPE" == "virtio-blk" ] ; then
			CNT=0

			for HDD in $(listvariables HD[0-9]\*) ; do
				# Evil hack to evaluate the contents of $HDD
				# as variable. For example: $$HDD -> $HD0 ->
				# /path/to/image
				eval HDD=\"\$$HDD\"

				if [ $HDD == "0" ] ; then
					continue
				fi

				CMD="$CMD -s 3:$CNT,$HDTYPE,$HDD"

				# Even more cruft
				if [ -z $SECTORSIZE ] ; then
					if [ $GOP_SECTORSIZE != 0 ] ; then
						CMD="$CMD,sectorsize=$GOP_SECTORSIZE "
					else
						CMD="$CMD "
					fi
				else
					if [ $SECTORSIZE != 0 ] ; then
						CMD="$CMD,sectorsize=$SECTORSIZE "
					else
						CMD="$CMD "
					fi
				fi

				CNT=$(($CNT + 1))
			done
		elif [ "$HDTYPE" == "ahci" ] ; then
			CMD="$CMD -s 3:0,$HDTYPE"

			for HDD in $(listvariables HD[0-9]\*) ; do
				# Evil hack to evaluate the contents of $HDD
				# as variable. For example: $$HDD -> $HD0 ->
				# /path/to/image
				eval HDD=\"\$$HDD\"

				if [ $HDD == "0" ] ; then
					continue
				fi

				CMD="$CMD,hd:$HDD"
				CNT=$(($CNT + 1))
			done
		elif [ "$HDTYPE" == "nvme" ] ; then
			CNT=0

			for HDD in $(listvariables HD[0-9]\*) ; do
				# Evil hack to evaluate the contents of $HDD
				# as variable. For example: $$HDD -> $HD0 ->
				# /path/to/image
				eval HDD=\"\$$HDD\"

				if [ $HDD == "0" ] ; then
					continue
				fi

				CMD="$CMD -s 3:$CNT,$HDTYPE,$HDD,maxq=$NVME_MAXQ"
				CMD="$CMD,qsz=$NVME_QSZ,ioslots=$NVME_IOSLOTS"
				CMD="$CMD,sectsz=$SECTORSIZE"

				CNT=$(($CNT + 1))
			done
		else
			return
		fi
	fi

	echo "$CMD"
}

# Builds a command list representing the
# CPU topology. The topology is consistent:
# numcpus = sockets * cores * threads.
buildtopology() {
	# Old configs are forced to one
	# socket with $CPU cores.
	if [ ! -z $CPUS ] ; then
		CORES=$CPUS
	fi

	dbg "Building CPU topology"

	# Ensure config is valid.
	if [ -z $SOCKETS ] ; then
		SOCKETS=1
	elif [ $SOCKETS -lt 1 ] ; then
		SOCKETS=1
	fi

	if [ -z $CORES ] ; then
		CORES=1
	elif [ $CORES -lt 1 ] ; then
		CORES=1
	fi

	if [ -z $THREADS ] ; then
		THREADS=1
	elif [ $THREADS -lt 1 ] ; then
		THREADS=1
	fi

	CPUS=$(($SOCKETS*$CORES*$THREADS))

	# Build command list
	CMD="cpus=$CPUS,sockets=$SOCKETS,cores=$CORES,threads=$THREADS"

	echo $CMD
}

# Checks if $BRIDGE exists and creates
# it if necessary.
createbridge() {
	/sbin/ifconfig $BRIDGE > /dev/null

	if [ $? -ne 0 ] ; then
		dbg "Creating $BRIDGE"

		/sbin/ifconfig $BRIDGE create
		/sbin/ifconfig $BRIDGE addm $EXTNIC stp $EXTNIC up
	fi
}

# Checks if the "up on open" sysctl for
# tap devices is set. If necessary it's
# value is changed to 1.
checkuponopen() {
	if [ `/sbin/sysctl -n net.link.tap.up_on_open` -ne 1 ] ; then
		dbg "Setting net.link.tap.up_on_open to 1"

		/sbin/sysctl net.link.tap.up_on_open=1 > /dev/null 2>&1
	fi
}

# Generates a unique ID for this instance.
generateid() {
	# Lock
    while [ true ] ; do
		if [ -e $RTDIR/id.lock ] ; then
			sleep 0.1
		else
			touch $RTDIR/id.lock
			break
		fi
	done

	dbg "Generating ID"

	# Create ID
	if [ -e $RTDIR/id ] ; then
		. $RTDIR/id

		for COUNT in $(seq 0 99) ; do
			MATCH=0

			for id in $UID ; do
				if [ $COUNT -eq $id ] ; then
					MATCH=1
				fi
			done

			# Mkay, this ID is unused.
			if [ $MATCH -eq 0 ] ; then
				echo "UID=\"$UID $COUNT\"" > $RTDIR/id
				rm $RTDIR/id.lock

				return $COUNT
			fi
		done

		# If we're here we're unable to find an ID.
		dbg "Maximum ID reached, sorry."

		rm $RTDIR/id.lock
		exit 1
	else
		# Save and unlock
		echo "UID=\"0\"" > $RTDIR/id
		rm $RTDIR/id.lock

		return 0
	fi
}

# Lists all set variables that match a pattern.
#  $1 -> Pattern
listvariables() {
	for VAR in $(set) ; do
		VAR="${VAR%%=*}"

		case "$VAR" in
			$1)
				echo $VAR
				;;
			*)
				continue
				;;
		esac
	done
}

# Removes the given ID from the list of used IDs.
#  $1 -> ID to remove
removeid() {
	# Lock
    while [ true ] ; do
		if [ -e $RTDIR/id.lock ] ; then
			sleep 0.1
		else
			touch $RTDIR/id.lock
			break
		fi
	done

	ls $RTDIR/*state > /dev/null 2>&1

	if [ $? -ne 0 ] ; then
		dbg "Last process, resetting ID"
		rm -rf $RTDIR/id
	else
		dbg "Not the last processing, freeing ID"
        . $RTDIR/id

		IDS=""

		for ID in $UID ; do
			if [ $ID -ne $1 ] ; then
				IDS="$IDS$ID "
			fi
		done

		echo "UID=\"$IDS\"" > $RTDIR/id
	fi

	# Unlock
	rm $RTDIR/id.lock
}

# Creates and configures a tap device.
#  $1 -> ID of the VM
createtap() {
	/sbin/ifconfig tap$1 > /dev/null 2>&1

	if [ $? -ne 0 ] ; then
		dbg "Creating tap$1"

		/sbin/ifconfig tap$1 create
		/sbin/ifconfig $BRIDGE addm tap$1 stp tap$1 up
		return $1
	else
		echo "tap$1 already existent"
		exit 1
	fi
}

# Transforms the process into a daemon.
becomedaemon() {
	dbg "Respawning as daemon"
	/usr/sbin/daemon -f $1 daemon $2
}


# Aborts if not running as root.
asroot() {
	if [ $(id -u) -ne 0 ] ; then
		echo "This can only be done as root."
		exit 1
	fi
}

# -------------------------------------------------------------------- #

# Runs a VM with bhyveload
run_bhyveload() {
	TAP=$1
	NMDMA=$2

	dbg "Calling bhyveload"

	if [ $BOOT = "cdrom" ] ; then
		dbg "Booting from CDROM"

		# Compatibility cruft for old configs
		if [ -z $CDROM0 ] ; then
			/usr/sbin/bhyveload -m $MEMORY -d $CDROM -c $NMDMA $NAME
		else
			/usr/sbin/bhyveload -m $MEMORY -d $CDROM0 -c $NMDMA $NAME
		fi
	elif [ $BOOT = "hd" ] ; then
		dbg "Booting from harddisk"

		# Compatibility cruft for old configs
		if [ -z $HD0 ] ; then
			/usr/sbin/bhyveload -m $MEMORY -d $HD -c $NMDMA $NAME
		else
			/usr/sbin/bhyveload -m $MEMORY -d $HD0 -c $NMDMA $NAME
		fi
	fi

	# Compatibility with old configs.
	if [ -z $HOSTBRIDGE ] ; then
		HOSTBRIDGE=hostbridge
	fi

	if [ -z $NICTYPE ] ; then
		NICTYPE=virtio-net
	fi

	CMD="/usr/sbin/bhyve -A -H -P -u -s 0,$HOSTBRIDGE -s 1,lpc"
	CMD="$CMD -s 2,$NICTYPE,$TAP $(buildhddlist) $(buildcdromlist)"
	CMD="$CMD -s 5,virtio-rnd -l com1,$NMDMA -c $(buildtopology)"
	CMD="$CMD -m $MEMORY $NAME"

	dbg "Calling bhyve: $CMD"
	$CMD >/dev/null 2>&1 &

	return $!
}

# Run VM with bootrom
run_bootrom() {
	TAP=$1
	NMDMA=$2

	# Compatibility with old configs.
	if [ -z $HOSTBRIDGE ] ; then
		HOSTBRIDGE=hostbridge
	fi

	if [ -z $NICTYPE ] ; then
		NICTYPE=virtio-net
	fi

	CMD="/usr/sbin/bhyve -H -P -u -w -s 0,$HOSTBRIDGE $(buildhddlist)"
	CMD="$CMD $(buildcdromlist) -s 10,$NICTYPE,$TAP -s 11,virtio-rnd"
	CMD="$CMD -s 31,lpc -l com1,$NMDMA -l bootrom,$BOOTROM"
	CMD="$CMD -c $(buildtopology) -m $MEMORY $NAME"

	dbg "Calling bhyve: $CMD"
	$CMD >/dev/null 2>&1 &

	return $!
}

# RUN VM with GOP instruction bootrom
run_bootrom_gop() {
	TAP=$1
	NMDMA=$2
	VNC=$3

	# Compatibility with old configs.
	if [ -z $HOSTBRIDGE ] ; then
		HOSTBRIDGE=hostbridge
	fi

	if [ -z $NICTYPE ] ; then
		NICTYPE=virtio-net
	fi

	CMD="/usr/sbin/bhyve -H -P -u -w -s 0,$HOSTBRIDGE"
	CMD="$CMD $(buildhddlist) $(buildcdromlist) "
	CMD="$CMD -s 11,fbuf,tcp=0.0.0.0:$VNC,w=$GOP_WIDTH,h=$GOP_HEIGHT"

	if [ $GOP_WAIT = 1 ] ; then
		CMD="$CMD,wait "
	else
		CMD="$CMD "
	fi

	CMD="$CMD -s 15,$NICTYPE,$TAP -s 16,virtio-rnd "

	if [ $GOP_TABLET = 1 ] ; then
		CMD="$CMD -s 20,xhci,tablet "
	fi

	CMD="$CMD -s 31,lpc -l com1,$NMDMA -l bootrom,$BOOTROM "
	CMD="$CMD -c $(buildtopology) -m $MEMORY $NAME"

	dbg "Calling bhyve: $CMD"
	$CMD >/dev/null 2>&1 &

	return $!
}

# Run VM with grub-bhyve
run_grub() {
	TAP=$1
	NMDMA=$2
	NMDMB=$3

	dbg "Calling grub-bhyve"

	# We need to write one bit into the virtual nullmodem
	# cable, otherwise grub-bhyve will wait forever for
	# user input. Wait 0.5 seconds for nmdm to open. This
	# is a dirty work around against possible races.
	true > $NMDMB &
	sleep 0.5

	/usr/local/sbin/grub-bhyve -r $BOOT -m $MAP -M $MEMORY -c $NMDMA $NAME &

	wait $!

	# Compatibility with old configs.
	if [ -z $HOSTBRIDGE ] ; then
		HOSTBRIDGE=hostbridge
	fi

	if [ -z $NICTYPE ] ; then
		NICTYPE=virtio-net
	fi

	CMD="/usr/sbin/bhyve -A -H -P -u -s 0,$HOSTBRIDGE -s 1,lpc"
	CMD="$CMD -s 2,$NICTYPE,$TAP $(buildhddlist) $(buildcdromlist)"
	CMD="$CMD -s 5,virtio-rnd -l com1,$NMDMA -c $(buildtopology)"
	CMD="$CMD -m $MEMORY $NAME"

	dbg "Calling bhyve: $CMD"
	$CMD >/dev/null 2>&1 &

	return $!
}

# -------------------------------------------------------------------- #

# Opens a serial console session
# to the VM.
console() {
	asroot

	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	# Call cu
	dbg "Calling cu"
	echo "Type ~ + ^d to exit"
	/usr/bin/cu -s 9600 -l $NMDMB
	echo "Console closed"
}

# Shuts a VM down by sending SIGTERM
# It will generate an ACPI shutdown
# event and send it to the guest.
haltvm() {
	asroot

 	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

 	if [ -z "$PID" ] ; then
		echo "VM is running, but Bhyve hasn't started yet"
		exit 1
	fi

	dbg "Sending SIGTERM to VM"
	kill -TERM $PID
}

# Kills a VM by sending SIGKILL.
killvm() {
	asroot

  	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	if [ -z "$PID" ] ; then
		echo "VM is running, but Bhyve hasn't started yet"
		exit 1
	fi

	dbg "Sending SIGKILL to VM"
	kill -KILL $PID
}

# Prints a list of all known VMs.
listvms() {
	dbg "Printing VMs in $VMDIR"

	overall_len=0

	for vm in $(ls $VMDIR) ; do
		if [ ! -f "$VMDIR/$vm/config.cfg" ] ; then
			continue
		fi

		if [ ${#vm} -gt $overall_len ] ; then
			overall_len=${#vm}
		fi
	done

	overall_len=$(($overall_len + 5))

	for vm in $(ls $VMDIR) ; do
		iteration=0
		padding=""

		if [ ! -f "$VMDIR/$vm/config.cfg" ] ; then
			continue
		fi

		while [ $iteration -lt $(($overall_len - ${#vm})) ] ; do
			padding="$padding."
			iteration=$(($iteration + 1))
		done

		if [ -e $RTDIR/$vm.state ] ; then
			if [ -e /dev/vmm/$vm ] ; then
				state="Running"
			else
				state="Stale PID file"
			fi
		else
			if [ -e /dev/vmm/$vm ] ; then
				state="Stale VM instance"
			else
				state="Stopped"
			fi
		fi

		printf "%s %s %s\n" "$vm" "$padding" "$state"
	done
}

# Prints a newline separated list of all VMs.
plainlistvms() {
	dbg "Printing VMs in $VMDIR"

	for vm in $(ls $VMDIR) ; do
		if [ ! -f "$VMDIR/$vm/config.cfg" ] ; then
			continue
		fi

		echo $vm
	done
}

# Runs the VM.
runvm() {
	asroot

	# Check if VM is still running
	if [ -e /dev/vmm/$NAME ] ; then
		echo "VM is still running."
		exit 1
	fi

	# Create working directory
	mkdir -p $RTDIR

	# Determine ID
	generateid
	ID=$?

	# Create the bridge
	createbridge

	# Create tap device
	checkuponopen
	createtap $ID
	TAP=tap$?

	# Determine nmdm interface to use
	NMDMA=/dev/nmdm_${ID}_${NAME}_A
	NMDMB=/dev/nmdm_${ID}_${NAME}_B

	# Determine a VNC port
	VNC=$(printf "59%02d" $ID)

	while [ true ] ; do

 		# Save state
		dbg "Saving state to $RTDIR/$NAME.state"
		echo "TAP=$TAP" > $RTDIR/$NAME.state
		echo "NMDMA=$NMDMA" >> $RTDIR/$NAME.state
		echo "NMDMB=$NMDMB" >> $RTDIR/$NAME.state
		echo "ID=$ID" >> $RTDIR/$NAME.state
		echo "VNC=$VNC" >> $RTDIR/$NAME.state

		# Load and run the VM
		if [ $LOADER = "bhyve" ] ; then
			run_bhyveload $TAP $NMDMA
			PID=$?
		elif [ $LOADER = "bootrom" ] ; then
			run_bootrom $TAP $NMDMA
			PID=$?
		elif [ $LOADER = "bootrom_gop" ] ; then
			run_bootrom_gop $TAP $NMDMA $VNC
			PID=$?
		elif [ $LOADER = "grub" ] ; then
			run_grub $TAP $NMDMA $NMDMB
			PID=$?
		else
			echo "Unknown LOADER method: $LOADER"
			break;
		fi

		# Save PID
		dbg "Saving PID to $RTDIR/$NAME.state"
		echo "PID=$PID" >> $RTDIR/$NAME.state

		# Wait for bhyve
		wait $PID

		# Return codes:
		# - 0: reset
		# - 1: powered off
		# - 2: halted
		# - 3: triple fault
		# - other: crash
		if [ $? -ne 0 ] ; then
			dbg "Shutdown"
			break
		fi

        # Grub is not reboot save. We need to
		# recreate the VM, otherwise Bhyve
		# will crash.
		if [ $LOADER = "grub" ] ; then
			/usr/sbin/bhyvectl --destroy --vm=$NAME
		fi

		dbg "Reboot"
	done

	# Cleanup
	/usr/sbin/bhyvectl --destroy --vm=$NAME > /dev/null 2>&1
	/sbin/ifconfig $BRIDGE deletem $TAP up
	/sbin/ifconfig $TAP destroy
	rm $RTDIR/$NAME.state
	removeid $ID
}

# Prints the status of VM.
status() {
	if [ -e $RTDIR/$NAME.state ] ; then
		if [ -e /dev/vmm/$NAME ] ; then
			echo "Running"
		else
			echo "Stale state file"
		fi
	else
		if [ -e /dev/vmm/$NAME ] ; then
			echo "Stale VM instance"
		else
			echo "Stopped"
		fi
	fi
}

# Opens vncviewer for the VM or returns the VNC port.
vnc() {
	if [ ! $LOADER = "bootrom_gop" ] ; then
		echo "Not a GOP VM"
		exit 1
	fi

	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	if [ ! -f "/usr/local/bin/vncviewer" ] ; then
		dbg "/usr/local/bin/vncviewer doesn't exists"
		echo "VNC port: $VNC"
	else
		dbg "Launching /usr/local/bin/vncviewer"
		/usr/local/bin/vncviewer 0.0.0.0:$VNC 2>&1 &
	fi
}

# -------------------------------------------------------------------- #

# Check if configuration dir exists
if [ ! -d $VMDIR ] ; then
	echo "$VMDIR doesn't exists or is not a directory"
	exit 1
fi

# Single parameter commands
if [ $# -eq 1 ] ; then
	case $1 in
		list)
			listvms
			;;
		plainlist)
			plainlistvms
			;;
		help)
			usage
			;;
		*)
			usage
			;;
	esac

	exit 0
fi

if [ $# -ne 2 ] ; then
	usage
fi

# Source VM config
NAME=$2
VMCFG="$VMDIR/$NAME/config.cfg"

if [ ! -f "$VMCFG" ] ; then
	echo "$NAME is not a valid VM"
	exit 1
fi

. $VMCFG

if [ $1 = "daemon" ] ; then
	runvm
else
	case $1 in
		cons)
			console
			;;
		halt)
			haltvm
			;;
		help)
			usage
			;;
		kill)
			killvm
			;;
		list)
			listvms
			;;
		run)
			if [ $DAEMON -ne 0 ] ; then
				becomedaemon $0 $NAME
			else
				runvm
			fi
			;;
		status)
			status
			;;
		vnc)
			vnc
			;;
		*)
			usage
			;;
	esac
fi
