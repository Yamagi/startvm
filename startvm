#!/bin/sh

# Copyright (c) 2014 - 2016 Yamagi Burmeister
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# -------------------------------------------------------------------- #

# Simple script to run a Bhvye virtual machine. You need to edit this
# script to match your setup! Before running this script make sure
# that the following kernel modules are loaded:
#  - if_bridge.ko
#  - if_tap.ko
#  - nmdm.ko
#  - vmm.ko
#
# All instances of this script must share the same configuration dir,
# otherwise strange things will happen. To boot other guests beside
# FreeBSD the sysutils/grub2-bhyve must be installed.

# -------------------------------------------------------------------- #

# Source system wide configuration
SCRIPTPATH=`readlink -f "$0"`
SCRIPTPATH=`dirname "$SCRIPTPATH"`
. $SCRIPTPATH/system.cfg

# -------------------------------------------------------------------- #

# Print usage.
usage() {
	echo "Usage: ./startvm.sh [vmname] cmd"
	echo ""
	echo "Commands:"
	echo " - cons:   Open a serial console to the guest"
	echo " - halt:   Send an ACPI shutdown request to the guest"
	echo " - help:   This message"
	echo " - kill:   Kill the VM"
	echo " - list:   List all known VMs"
	echo " - run:    Run the VM"
	echo " - status: Show status"
	exit 1
}

# Debug output.
dbg() {
	if [ $DEBUG -ne 0 ] ; then
		echo $1
	fi
}

# Checks if $BRIDGE exists and creates
# it if necessary.
createbridge() {
	/sbin/ifconfig $BRIDGE > /dev/null

	if [ $? -ne 0 ] ; then
		dbg "Creating $BRIDGE"

		/sbin/ifconfig $BRIDGE create
		/sbin/ifconfig $BRIDGE addm $EXTNIC stp $EXTNIC up
	fi
}

# Checks if the "up on open" sysctl for
# tap devices is set. If necessary it's
# value is changed to 1.
checkuponopen() {
	if [ `/sbin/sysctl -n net.link.tap.up_on_open` -ne 1 ] ; then
		dbg "Setting net.link.tap.up_on_open to 1"

		/sbin/sysctl net.link.tap.up_on_open=1 > /dev/null 2>&1
	fi
}

# Generates a unique ID for this instance.
generateid() {
	# Lock
    while [ true ] ; do
		if [ -e $RTDIR/id.lock ] ; then
			sleep 0.1
		else
			touch $RTDIR/id.lock
			break
		fi
	done

	# Create ID
	if [ -e $RTDIR/id ] ; then
		. $RTDIR/id
		UID=$((UID + 1))
	else
		UID=0
	fi

	echo "UID=$UID" > $RTDIR/id

	# Unlock
	rm $RTDIR/id.lock

	return $UID
}

# Resets the ID if the last instance exits.
resetid() {
	# Lock
    while [ true ] ; do
		if [ -e $RTDIR/id.lock ] ; then
			sleep 0.1
		else
			touch $RTDIR/id.lock
			break
		fi
	done

	ls $RTDIR/*state > /dev/null 2>&1

	if [ $? -ne 0 ] ; then
		dbg "Last process, reseting ID"
		rm -rf $RTDIR/id
	fi

	# Unlock
	rm $RTDIR/id.lock
}

# Creates and configures a tap device.
#  $1 -> ID of the VM
createtap() {
	/sbin/ifconfig tap$1 > /dev/null 2>&1

	if [ $? -ne 0 ] ; then
		dbg "Creating tap$1"

		/sbin/ifconfig tap$1 create
		/sbin/ifconfig $BRIDGE addm tap$1 stp tap$1 up
		return $1
	else
		echo "tap$1 already existant"
		exit 1
	fi
}

# Transforms the process into a daemon.
becomedaemon() {
	dbg "Respawning as daemon"
	/usr/sbin/daemon -f $1 daemon $2
}


# Aborts if not running as root.
asroot() {
	if [ $(id -u) -ne 0 ] ; then
		echo "This can only be done as root."
		exit 1
	fi
}

# -------------------------------------------------------------------- #

# Runs a VM with bhyveload
run_bhyveload() {
	TAP=$1
	NMDMA=$2

	dbg "Calling bhyveload"

	if [ $BOOT = "cdrom" ] ; then
		dbg "Booting from CDROM"
		/usr/sbin/bhyveload -m $MEMORY -d $CDROM -c $NMDMA $NAME
	elif [ $BOOT = "hd" ] ; then
		dbg "Booting from harddisk"
		/usr/sbin/bhyveload -m $MEMORY -d $HD -c $NMDMA $NAME
	fi

	dbg "Calling bhyve"

	if [ $CDROM = 0 ] ; then
		/usr/sbin/bhyve -A -H -P -u -s 0,hostbridge -s 1,lpc \
			-s 2,virtio-net,$TAP -s 3,ahci-hd,$HD -s 4,virtio-rnd \
			-l com1,$NMDMA -c $CPUS -m $MEMORY $NAME > /dev/null 2>&1 &
	else
		/usr/sbin/bhyve -A -H -P -u -s 0,hostbridge -s 1,lpc \
			-s 2,virtio-net,$TAP -s 3,ahci-hd,$HD -s 4,ahci-cd,$CDROM \
			-s 5,virtio-rnd -l com1,$NMDMA -c $CPUS -m $MEMORY $NAME \
			> /dev/null 2>&1 &
	fi

	return $!
}

# Run VM with bootrom
run_bootrom() {
	TAP=$1
	NMDMA=$2

	dbg "Calling bhyve"

	# The UEFI CSM firmware requires AHCI devices at slot
	# 3, 4, 5 and 6. Otherwise the system will not boot.
	# The LPC / ISA bus should be at port 31.
	if [ $CDROM = 0 ] ; then
		/usr/sbin/bhyve -A -H -P -u -w -s 0,hostbridge -s 3,ahci-hd,$HD \
			-s 10,virtio-net,$TAP -s 11,virtio-rnd, -s 31,lpc \
			-l com1,$NMDMA -l bootrom,$BOOTROM -c $CPUS -m $MEMORY $NAME \
			> /dev/null 2>&1 &
	else
		/usr/sbin/bhyve -A -H -P -u -w -s 0,hostbridge -s 3,ahci-hd,$HD \
			-s 4,ahci-cd,$CDROM -s 10,virtio-net,$TAP -s 11,virtio-rnd, \
			-s 31,lpc -l com1,$NMDMA -l bootrom,$BOOTROM -c $CPUS -m $MEMORY \
			$NAME > /dev/null 2>&1 &
	fi

	return $!
}

# RUN VM with GOP instruction bootrom
run_bootrom_gop() {
	TAP=$1
	NMDMA=$2
	VNC=$3

	dbg "Calling bhyve"

	CMD="/usr/sbin/bhyve -A -H -P -u -w -s 0,hostbridge "
	CMD="$CMD -s 3,ahci-hd,$HD "

	if [ $CDROM = 1 ] ; then
		CMD="$CMD -s 4,ahci-cd,$CDROM "
	fi

	CMD="$CMD -s 11,fbuf,tcp=0.0.0.0:$VNC,w=$GOP_WIDTH,h=$GOP_HEIGHT"

	if [ $GOP_WAIT = 1 ] ; then
		CMD="$CMD,wait "
	else
		CMD="$CMD "
	fi

	CMD="$CMD -s 15,virtio-net,$TAP -s 16,virtio-rnd "

	if [ $GOP_TABLET = 1 ] ; then
		CMD="$CMD -s 20,xhci,tablet "
	fi

	CMD="$CMD -s 31,lpc -l com1,$NMDMA -l bootrom,$BOOTROM "
	CMD="$CMD -c $CPUS -m $MEMORY $NAME"

	$CMD > /dev/null 2>&1 &

	return $!
}

# Run VM with grub-bhyve
run_grub() {
	TAP=$1
	NMDMA=$2
	NMDMB=$3

	dbg "Calling grub-bhyve"

	# We need to write one bit into the virtual nullmodem
	# cable, otherwise grub-bhyve will wait forever for
	# user input. Wait 0.5 seconds for nmdm to open. This
	# is a dirty work around against possible races.
	true > $NMDMB &
	sleep 0.5

	/usr/local/sbin/grub-bhyve -r $BOOT -m $MAP -M $MEMORY -c $NMDMA $NAME &

	wait $!

	dbg "Calling bhyve"

	if [ $CDROM = 0 ] ; then
		/usr/sbin/bhyve -A -H -P -u -s 0,hostbridge -s 1,lpc \
			-s 2,virtio-net,$TAP -s 3,ahci-hd,$HD -s 4,virtio-rnd \
			-l com1,$NMDMA -c $CPUS -m $MEMORY $NAME > /dev/null 2>&1 &
	else
		/usr/sbin/bhyve -A -H -P -u -s 0,hostbridge -s 1,lpc \
			-s 2,virtio-net,$TAP -s 3,ahci-hd,$HD -s 4,ahci-cd,$CDROM \
			-s 5,virtio-rnd -l com1,$NMDMA -c $CPUS -m $MEMORY $NAME \
			> /dev/null 2>&1 &
	fi

	return $!
}

# -------------------------------------------------------------------- #

# Opens a serial console session
# to the VM.
console() {
	asroot

	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	# Call cu
	dbg "Calling cu"
	echo "Type ~ + ^d to exit"
	/usr/bin/cu -s 9600 -l $NMDMB
	echo "Console closed"
}

# Shuts a VM down by sending SIGTERM
# It will generate an ACPI shutdown
# event and send it to the guest.
haltvm() {
	asroot

 	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

 	if [ -z "$PID" ] ; then
		echo "VM is running, but Bhyve hasn't started yet"
		exit 1
	fi

	dbg "Sending SIGTERM to VM"
	kill -TERM $PID
}

# Kills a VM by sending SIGKILL.
killvm() {
	asroot

  	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	if [ -z "$PID" ] ; then
		echo "VM is running, but Bhyve hasn't started yet"
		exit 1
	fi

	dbg "Sending SIGKILL to VM"
	kill -KILL $PID
}

# Prints a list of all known VMs
listvms() {
	dbg "Printing VMs in $VMDIR"

	overall_len=0

	for vm in $(ls $VMDIR) ; do
		if [ ! -f "$VMDIR/$vm/config.cfg" ] ; then
			continue
		fi

		if [ ${#vm} -gt $overall_len ] ; then
			overall_len=${#vm}
		fi
	done

	overall_len=$(($overall_len + 5))

	for vm in $(ls $VMDIR) ; do
		iteration=0
		padding=""

		if [ ! -f "$VMDIR/$vm/config.cfg" ] ; then
			continue
		fi

		while [ $iteration -lt $(($overall_len - ${#vm})) ] ; do
			padding="$padding."
			iteration=$(($iteration + 1))
		done

		if [ -e $RTDIR/$vm.state ] ; then
			if [ -e /dev/vmm/$vm ] ; then
				state="Running"
			else
				state="Stale PID file"
			fi
		else
			if [ -e /dev/vmm/$vm ] ; then
				state="Stale VM instance"
			else
				state="Stopped"
			fi
		fi

		printf "%s %s %s\n" "$vm" "$padding" "$state"
	done
}

# Runs the VM.
runvm() {
	asroot

	# Check if VM is still running
	if [ -e /dev/vmm/$NAME ] ; then
		echo "VM is still running."
		exit 1
	fi

	# Create working directory
	mkdir -p $RTDIR

	# Determine ID
	generateid
	ID=$?

	# Create the bridge
	createbridge

	# Create tap device
	checkuponopen
	createtap $ID
	TAP=tap$?

	# Determine nmdm interface to use
	NMDMA=/dev/nmdm_${ID}_${NAME}_A
	NMDMB=/dev/nmdm_${ID}_${NAME}_B

	# Determine a VNC port
	VNC=$(printf "59%02d" $ID)

	while [ true ] ; do

 		# Save state
		dbg "Saving state to $RTDIR/$NAME.state"
		echo "TAP=$TAP" > $RTDIR/$NAME.state
		echo "NMDMA=$NMDMA" >> $RTDIR/$NAME.state
		echo "NMDMB=$NMDMB" >> $RTDIR/$NAME.state
		echo "ID=$ID" >> $RTDIR/$NAME.state
		echo "VNC=$VNC" >> $RTDIR/$NAME.state

		# Load and run the VM
		if [ $LOADER = "bhyve" ] ; then
			run_bhyveload $TAP $NMDMA
			PID=$?
		elif [ $LOADER = "bootrom" ] ; then
			run_bootrom $TAP $NMDMA
			PID=$?
		elif [ $LOADER = "bootrom_gop" ] ; then
			run_bootrom_gop $TAP $NMDMA $VNC
			PID=$?
		elif [ $LOADER = "grub" ] ; then
			run_grub $TAP $NMDMA $NMDMB
			PID=$?
		else
			echo "Unknown LOADER method: $LOADER"
			break;
		fi

		# Save PID
		dbg "Saving PID to $RTDIR/$NAME.state"
		echo "PID=$PID" >> $RTDIR/$NAME.state

		# Wait for bhyve
		wait $PID

		# Return codes:
		# - 0: reset
		# - 1: powered off
		# - 2: halted
		# - 3: triple fault
		# - other: crash
		if [ $? -ne 0 ] ; then
			dbg "Shutdown"
			break
		fi

        # Grub is not reboot save. We need to
		# recreate the VM, otherwise Bhyve
		# will crash.
		if [ $LOADER = "grub" ] ; then
			/usr/sbin/bhyvectl --destroy --vm=$NAME
		fi

		dbg "Reboot"
	done

	# Cleanup
	/usr/sbin/bhyvectl --destroy --vm=$NAME > /dev/null 2>&1
	/sbin/ifconfig $BRIDGE deletem $TAP up
	/sbin/ifconfig $TAP destroy
	rm $RTDIR/$NAME.state
	resetid
}

# Prints the status of VM.
status() {
	if [ -e $RTDIR/$NAME.state ] ; then
		if [ -e /dev/vmm/$NAME ] ; then
			echo "Running"
		else
			echo "Stale state file"
		fi
	else
		if [ -e /dev/vmm/$NAME ] ; then
			echo "Stale VM instance"
		else
			echo "Stopped"
		fi
	fi
}

# Opens vncviewer for the VM or returns the VNC port.
vnc() {
	if [ ! $LOADER = "bootrom_gop" ] ; then
		echo "Not a GOP VM"
		exit 1
	fi

	if [ ! -e $RTDIR/$NAME.state ] ; then
		echo "VM is not running"
		exit 1
	fi

	. $RTDIR/$NAME.state

	if [ ! -f "/usr/local/bin/vncviewer" ] ; then
		dbg "/usr/local/bin/vncviewer doesn't exists"
		echo "VNC port: $VNC"
	else
		dbg "Launching /usr/local/bin/vncviewer"
		/usr/local/bin/vncviewer 0.0.0.0:$VNC 2>&1 &
	fi
}

# -------------------------------------------------------------------- #

# Check if configuration dir exists
if [ ! -d $VMDIR ] ; then
	echo "$VMDIR doesn't exists or is not a directory"
	exit 1
fi

# Single parameter commands
if [ $# -eq 1 ] ; then
	case $1 in
		list)
			listvms
			;;
		help)
			usage
			;;
		*)
			usage
			;;
	esac

	exit 0
fi

if [ $# -ne 2 ] ; then
	usage
fi

# Source VM config
NAME=$2
VMCFG="$VMDIR/$NAME/config.cfg"

if [ ! -f "$VMCFG" ] ; then
	echo "$NAME is not a valid VM"
	exit 1
fi

. $VMCFG

if [ $1 = "daemon" ] ; then
	runvm
else
	case $1 in
		cons)
			console
			;;
		halt)
			haltvm
			;;
		help)
			usage
			;;
		kill)
			killvm
			;;
		list)
			listvms
			;;
		run)
			if [ $DAEMON -ne 0 ] ; then
				becomedaemon $0 $NAME
			else
				runvm
			fi
			;;
		status)
			status
			;;
		vnc)
			vnc
			;;
		*)
			usage
			;;
	esac
fi
